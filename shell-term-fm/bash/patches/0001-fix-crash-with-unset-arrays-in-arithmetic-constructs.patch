From 30e638de97eb08200ee9ddde9ff6bc7917888587 Mon Sep 17 00:00:00 2001
From: Chet Ramey <chet.ramey@case.edu>
Date: Tue, 4 Oct 2022 11:58:54 -0400
Subject: [PATCH] fix crash with unset arrays in arithmetic constructs ; change
 to avoid printing foreground job statuses when we don't want to

Upstream-Status: Backport
[ismael@sourcemage.org: Backported to 5.2.26]
Signed-off-by: Ismael Luceno <ismael@sourcemage.org>
---
 CWRU/changelog       |   70 +++++++++++++++++++++++++++++++++++++++++++++++++++
 builtins/wait.def    |    2 -
 configure            |    7 +++--
 execute_cmd.c        |    7 +++--
 jobs.c               |   26 ++++++++++++++++--
 lib/readline/input.c |    2 -
 m4/strtoimax.m4      |    6 ++--
 tests/array.right    |    2 +
 tests/array27.sub    |    3 ++
 9 files changed, 114 insertions(+), 11 deletions(-)

diff --git a/CWRU/changelog b/CWRU/changelog
index da6d4aa1c362..c5286520f8ec 100644
--- a/CWRU/changelog
+++ b/CWRU/changelog
@@ -3950,3 +3950,73 @@ lib/readline/history.c
 				   9/23
 				   ----
 [bash-5.2 frozen]
+
+				   9/26
+				   ----
+[bash-5.2 released]
+
+				   9/27
+				   ----
+mailcheck.c
+	- time_to_check_mail: don't bother if we're in the middle of readline
+	  completion or command dispatching.
+	  From https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1019462
+
+lib/readline/display.c
+	- rl_forced_update_display: use memset to clear out visible_line
+	  instead of trying to use a loop; line_size is the size.
+	  Report from <srobertson@peratonlabs.com>
+
+print_cmd.c
+	- indirection_level_string: use MBRLEN and an initialized mbstate_t
+	  object to avoid altering an internal mbstate_t.
+	  From Koichi Murase <myoga.murase@gmail.com>
+
+subst.c
+	- string_extract_verbatim: use an explicit mbstate_t object and pass
+	  it to MBRLEN and mbrtowc to avoid altering the state that
+	  ADVANCE_CHAR is using.
+	  From Koichi Murase <myoga.murase@gmail.com>
+	- setifs: use an explicit mbstate_t object and pass it to MBRLEN so
+	  to avoid altering an internal mbstate_t.
+	  From Koichi Murase <myoga.murase@gmail.com>
+
+builtins/printf.def
+	- asciicode: use an explicit mbstate_t object and pass it to mbrtowc
+	  to avoid using an incorrect internal mbstate_t
+	  From Koichi Murase <myoga.murase@gmail.com>
+
+lib/sh/{mbscasecmp,mbscmp}.c
+	- mbscasecmp,mbscmp: use different mbstate_t objects for the different
+	  strings so they don't affect each others' intermediate mbstate.
+	  From Koichi Murase <myoga.murase@gmail.com>
+
+				   9/28
+				   ----
+execute_cmd.c
+	- execute_command_internal: if executing a (command) subshell, restore
+	  the value of line_number from save_line_number before returning early
+	  due to being a non-terminal pipeline element.
+	  From https://savannah.gnu.org/support/index.php?110714
+
+				   9/30
+				   ----
+subst.c
+	- expand_array_subscript: make sure to pass a non-NULL first argument
+	  to sh_backslash_quote. Report from Emanuele Torre <torreemanuele6@gmail.com>,
+	  patch from Koichi Murase <myoga.murase@gmail.com>
+
+				   9/30
+				   ----
+jobs.c
+	- cleanup_dead_jobs: delete dead foreground jobs we won't notify the
+	  user about (those not killed by a signal or killed by SIGINT/SIGPIPE).
+	  From a report from Koichi Murase <myoga.murase@gmail.com>
+	- wait_for_any_job: never return a foreground job, even when requested
+	  by pid, if it's in the jobs list
+	  Report and fix from Koichi Murase <myoga.murase@gmail.com>
+
+m4/strtoimax.m4
+	- BASH_FUNC_STRTOIMAX: fix logic inversion of result; we should be
+	  replacing the function if the tests show we *don't* have a working
+	  version. Report from Emanuel Haupt <ehaupt@FreeBSD.org>
diff --git a/builtins/wait.def b/builtins/wait.def
index b066d78d0e51..1a49430a39e1 100644
--- a/builtins/wait.def
+++ b/builtins/wait.def
@@ -1,4 +1,4 @@
-'This file is wait.def, from which is created wait.c.
+This file is wait.def, from which is created wait.c.
 It implements the builtin "wait" in Bash.
 
 Copyright (C) 1987-2021 Free Software Foundation, Inc.
diff --git a/configure b/configure
index 47313753e717..feeaaa183460 100755
--- a/configure
+++ b/configure
@@ -20432,7 +20432,6 @@ printf "%s\n" "#define HAVE_DECL_STRTOIMAX $ac_have_decl" >>confdefs.h
   if test "$ac_cv_have_decl_strtoimax" = "yes" ; then
     HAVE_DECL_STRTOIMAX=1
   fi
-
   if test "$HAVE_STRTOIMAX" = 0 || test "$HAVE_DECL_STRTOIMAX" = 0 ; then
     bash_cv_func_strtoimax=no REPLACE_STRTOIMAX=1
   else
@@ -20443,7 +20442,11 @@ fi
 
 { printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $bash_cv_func_strtoimax" >&5
 printf "%s\n" "$bash_cv_func_strtoimax" >&6; }
-if test $bash_cv_func_strtoimax = yes; then
+if test "$ac_cv_have_decl_strtoimax" = "yes" ; then
+printf "%s\n" "#define HAVE_DECL_STRTOIMAX 1" >>confdefs.h
+
+fi
+if test $bash_cv_func_strtoimax = no; then
 case " $LIBOBJS " in
   *" strtoimax.$ac_objext "* ) ;;
   *) LIBOBJS="$LIBOBJS strtoimax.$ac_objext"
diff --git a/execute_cmd.c b/execute_cmd.c
index ed1063e6b6b0..e772612375a9 100644
--- a/execute_cmd.c
+++ b/execute_cmd.c
@@ -648,6 +648,7 @@ execute_command_internal (command, asynchronous, pipe_in, pipe_out,
       save_line_number = line_number;
       if (command->type == cm_subshell)
 	SET_LINE_NUMBER (command->value.Subshell->line);	/* XXX - save value? */
+
 	/* Otherwise we defer setting line_number */
       tcmd = make_command_string (command);
       fork_flags = asynchronous ? FORK_ASYNC : 0;
@@ -690,6 +691,10 @@ execute_command_internal (command, asynchronous, pipe_in, pipe_out,
 	  if (variable_context == 0)	/* wait until shell function completes */
 	    unlink_fifo_list ();
 #endif
+
+	  /* Restore any saved state here before possible early return. */
+	  line_number = save_line_number;
+
 	  /* If we are part of a pipeline, and not the end of the pipeline,
 	     then we should simply return and let the last command in the
 	     pipe be waited for.  If we are not in a pipeline, or are the
@@ -700,8 +705,6 @@ execute_command_internal (command, asynchronous, pipe_in, pipe_out,
 
 	  stop_pipeline (asynchronous, (COMMAND *)NULL);
 
-	  line_number = save_line_number;
-
 	  if (asynchronous == 0)
 	    {
 	      was_error_trap = signal_is_trapped (ERROR_TRAP) && signal_is_ignored (ERROR_TRAP) == 0;
diff --git a/jobs.c b/jobs.c
index b96230fa7226..fa3334a853ab 100644
--- a/jobs.c
+++ b/jobs.c
@@ -270,6 +270,8 @@ static int set_job_status_and_cleanup PARAMS((int));
 static WAIT job_signal_status PARAMS((int));
 static WAIT raw_job_exit_status PARAMS((int));
 
+static int job_killed_by_signal PARAMS((int));
+
 static void notify_of_job_status PARAMS((void));
 static void reset_job_indices PARAMS((void));
 static void cleanup_dead_jobs PARAMS((void));
@@ -1226,8 +1228,12 @@ cleanup_dead_jobs ()
       if (i > js.j_lastj && jobs[i])
 	INTERNAL_DEBUG(("cleanup_dead_jobs: job %d non-null after js.j_lastj (%d)", i, js.j_lastj));
 
-      if (jobs[i] && DEADJOB (i) && IS_NOTIFIED (i))
-	delete_job (i, 0);
+      if (jobs[i] == 0 || DEADJOB (i) == 0)
+	continue;		/* not a candidate */
+      else if (IS_NOTIFIED (i))
+	delete_job (i, 0);	/* already notified */
+      else if (IS_FOREGROUND (i) && job_killed_by_signal (i) == 0)
+	delete_job (i, 0);	/* we won't notify about this */
     }
 
 #if defined (PROCESS_SUBSTITUTION)
@@ -2876,6 +2882,20 @@ job_exit_signal (job)
   return (process_exit_signal (raw_job_exit_status (job)));
 }
 
+static int
+job_killed_by_signal (job)
+     int job;
+{
+  int termsig;
+
+  termsig = job_exit_signal (job);
+#if !defined (DONT_REPORT_SIGPIPE)
+  return (termsig && termsig != SIGINT);
+#else
+  return (termsig && termsig != SIGINT && termsig != SIGPIPE);
+#endif
+}
+
 #define FIND_CHILD(pid, child) \
   do \
     { \
@@ -3287,7 +3307,7 @@ wait_for_any_job (flags, ps)
     {
       if ((flags & JWAIT_WAITING) && jobs[i] && IS_WAITING (i) == 0)
 	continue;		/* if we don't want it, skip it */
-      if (jobs[i] && DEADJOB (i) && IS_NOTIFIED (i) == 0)
+      if (jobs[i] && DEADJOB (i) && IS_NOTIFIED (i) == 0 && IS_FOREGROUND (i) == 0)
 	{
 return_job:
 	  r = job_exit_status (i);
diff --git a/lib/readline/input.c b/lib/readline/input.c
index 6f038d4508a4..8c5d6fb65ad4 100644
--- a/lib/readline/input.c
+++ b/lib/readline/input.c
@@ -818,7 +818,7 @@ rl_getc (FILE *stream)
       /* We know at this point that _rl_caught_signal == 0 */
 
 #if defined (__MINGW32__)
-      if (isatty (fd)
+      if (isatty (fd))
 	return (_getch ());	/* "There is no error return." */
 #endif
       result = 0;
diff --git a/m4/strtoimax.m4 b/m4/strtoimax.m4
index 309857235fea..4d6cb3ba8843 100644
--- a/m4/strtoimax.m4
+++ b/m4/strtoimax.m4
@@ -21,7 +21,6 @@ AC_CACHE_VAL(bash_cv_func_strtoimax,
   if test "$ac_cv_have_decl_strtoimax" = "yes" ; then
     HAVE_DECL_STRTOIMAX=1
   fi
-
   if test "$HAVE_STRTOIMAX" = 0 || test "$HAVE_DECL_STRTOIMAX" = 0 ; then
     bash_cv_func_strtoimax=no REPLACE_STRTOIMAX=1
   else
@@ -29,7 +28,10 @@ AC_CACHE_VAL(bash_cv_func_strtoimax,
   fi
 ])
 AC_MSG_RESULT($bash_cv_func_strtoimax)
-if test $bash_cv_func_strtoimax = yes; then
+if test "$ac_cv_have_decl_strtoimax" = "yes" ; then
+AC_DEFINE([HAVE_DECL_STRTOIMAX], [1])
+fi
+if test $bash_cv_func_strtoimax = no; then
 AC_LIBOBJ(strtoimax)
 fi
 ])
diff --git a/tests/array.right b/tests/array.right
index 62278852a634..36d4936363b4 100644
--- a/tests/array.right
+++ b/tests/array.right
@@ -757,6 +757,8 @@ declare -A A=([$'\t']="X" ["*"]="X" [" "]="X" ["@"]="X" )
 declare -A A=(["*"]="X" ["@"]="X" )
 ./array27.sub: line 76: declare: `A[]]=X': not a valid identifier
 declare -A A=(["*"]="X" ["@"]="X" )
+./array27.sub: line 81: y[]: bad array subscript
+./array27.sub: line 81: y[]: bad array subscript
 declare -a bug4=([0]="" [1]="5" [2]="" [3]="1" [4]="")
 declare -a bug=([0]="" [1]="5" [2]="" [3]="1" [4]="")
 declare -a bug2=([0]="")
diff --git a/tests/array27.sub b/tests/array27.sub
index e2a1e708360a..856456414071 100644
--- a/tests/array27.sub
+++ b/tests/array27.sub
@@ -76,3 +76,6 @@ for k in ']' '*' '@'; do
    declare "A[$k]=X"
 done
 declare -p A
+
+# empty arrays in arith contexts
+(( y[$none] ))
-- 
2.44.0

