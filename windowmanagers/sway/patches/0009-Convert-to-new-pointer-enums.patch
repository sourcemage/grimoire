From b2e33ad1468e9a663618a39ec822d2df8c4d220a Mon Sep 17 00:00:00 2001
From: Simon Ser <contact@emersion.fr>
Date: Wed, 28 Feb 2024 17:49:58 +0100
Subject: [PATCH 09/15] Convert to new pointer enums

References: https://gitlab.freedesktop.org/wlroots/wlroots/-/merge_requests/4575
Origin: Upstream
Upstream-Status: Backported [commit fca8474e9bd64bff8df16fdaf409d5f575ba9501]
Signed-off-by: Ismael Luceno <ismael@sourcemage.org>
---
 include/sway/input/cursor.h         |  2 +-
 include/sway/input/seat.h           |  6 ++---
 sway/commands/seat/cursor.c         | 14 ++++++------
 sway/input/cursor.c                 | 16 +++++++-------
 sway/input/seat.c                   |  4 ++--
 sway/input/seatop_default.c         | 34 ++++++++++++++---------------
 sway/input/seatop_down.c            |  2 +-
 sway/input/seatop_move_floating.c   |  2 +-
 sway/input/seatop_move_tiling.c     |  2 +-
 sway/input/seatop_resize_floating.c |  2 +-
 sway/input/seatop_resize_tiling.c   |  2 +-
 11 files changed, 43 insertions(+), 43 deletions(-)

diff --git a/include/sway/input/cursor.h b/include/sway/input/cursor.h
index 1e21c66fe326..527d03500c70 100644
--- a/include/sway/input/cursor.h
+++ b/include/sway/input/cursor.h
@@ -114,7 +114,7 @@ void pointer_motion(struct sway_cursor *cursor, uint32_t time_msec,
 
 void dispatch_cursor_button(struct sway_cursor *cursor,
 	struct wlr_input_device *device, uint32_t time_msec, uint32_t button,
-	enum wlr_button_state state);
+	enum wl_pointer_button_state state);
 
 void dispatch_cursor_axis(struct sway_cursor *cursor,
 		struct wlr_pointer_axis_event *event);
diff --git a/include/sway/input/seat.h b/include/sway/input/seat.h
index 97e81c1902c4..112d18b8952f 100644
--- a/include/sway/input/seat.h
+++ b/include/sway/input/seat.h
@@ -17,7 +17,7 @@ struct render_context;
 struct sway_seatop_impl {
 	void (*button)(struct sway_seat *seat, uint32_t time_msec,
 			struct wlr_input_device *device, uint32_t button,
-			enum wlr_button_state state);
+			enum wl_pointer_button_state state);
 	void (*pointer_motion)(struct sway_seat *seat, uint32_t time_msec);
 	void (*pointer_axis)(struct sway_seat *seat,
 			struct wlr_pointer_axis_event *event);
@@ -296,13 +296,13 @@ struct sway_container *seat_get_focus_inactive_floating(struct sway_seat *seat,
 		struct sway_workspace *workspace);
 
 void seat_pointer_notify_button(struct sway_seat *seat, uint32_t time_msec,
-		uint32_t button, enum wlr_button_state state);
+		uint32_t button, enum wl_pointer_button_state state);
 
 void seat_consider_warp_to_focus(struct sway_seat *seat);
 
 void seatop_button(struct sway_seat *seat, uint32_t time_msec,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state);
+		enum wl_pointer_button_state state);
 
 void seatop_pointer_motion(struct sway_seat *seat, uint32_t time_msec);
 
diff --git a/sway/commands/seat/cursor.c b/sway/commands/seat/cursor.c
index 5a8a3bc8f770..7236f27f2925 100644
--- a/sway/commands/seat/cursor.c
+++ b/sway/commands/seat/cursor.c
@@ -85,12 +85,12 @@ struct cmd_results *seat_cmd_cursor(int argc, char **argv) {
 
 static struct cmd_results *press_or_release(struct sway_cursor *cursor,
 		char *action, char *button_str) {
-	enum wlr_button_state state;
+	enum wl_pointer_button_state state;
 	uint32_t button;
 	if (strcasecmp(action, "press") == 0) {
-		state = WLR_BUTTON_PRESSED;
+		state = WL_POINTER_BUTTON_STATE_PRESSED;
 	} else if (strcasecmp(action, "release") == 0) {
-		state = WLR_BUTTON_RELEASED;
+		state = WL_POINTER_BUTTON_STATE_RELEASED;
 	} else {
 		return cmd_results_new(CMD_INVALID, "%s", expected_syntax);
 	}
@@ -105,16 +105,16 @@ static struct cmd_results *press_or_release(struct sway_cursor *cursor,
 	} else if (button == SWAY_SCROLL_UP || button == SWAY_SCROLL_DOWN
 			|| button == SWAY_SCROLL_LEFT || button == SWAY_SCROLL_RIGHT) {
 		// Dispatch axis event
-		enum wlr_axis_orientation orientation =
+		enum wl_pointer_axis orientation =
 			(button == SWAY_SCROLL_UP || button == SWAY_SCROLL_DOWN)
-			? WLR_AXIS_ORIENTATION_VERTICAL
-			: WLR_AXIS_ORIENTATION_HORIZONTAL;
+			? WL_POINTER_AXIS_VERTICAL_SCROLL
+			: WL_POINTER_AXIS_HORIZONTAL_SCROLL;
 		double delta = (button == SWAY_SCROLL_UP || button == SWAY_SCROLL_LEFT)
 			? -1 : 1;
 		struct wlr_pointer_axis_event event = {
 			.pointer = NULL,
 			.time_msec = 0,
-			.source = WLR_AXIS_SOURCE_WHEEL,
+			.source = WL_POINTER_AXIS_SOURCE_WHEEL,
 			.orientation = orientation,
 			.delta = delta * 15,
 			.delta_discrete = delta
diff --git a/sway/input/cursor.c b/sway/input/cursor.c
index 36aab93e23f8..a275045e0603 100644
--- a/sway/input/cursor.c
+++ b/sway/input/cursor.c
@@ -429,7 +429,7 @@ static void handle_pointer_motion_absolute(
 
 void dispatch_cursor_button(struct sway_cursor *cursor,
 		struct wlr_input_device *device, uint32_t time_msec, uint32_t button,
-		enum wlr_button_state state) {
+		enum wl_pointer_button_state state) {
 	if (time_msec == 0) {
 		time_msec = get_current_time_msec();
 	}
@@ -441,7 +441,7 @@ static void handle_pointer_button(struct wl_listener *listener, void *data) {
 	struct sway_cursor *cursor = wl_container_of(listener, cursor, button);
 	struct wlr_pointer_button_event *event = data;
 
-	if (event->state == WLR_BUTTON_PRESSED) {
+	if (event->state == WL_POINTER_BUTTON_STATE_PRESSED) {
 		cursor->pressed_button_count++;
 	} else {
 		if (cursor->pressed_button_count > 0) {
@@ -503,7 +503,7 @@ static void handle_touch_up(struct wl_listener *listener, void *data) {
 		if (cursor->pointer_touch_id == cursor->seat->touch_id) {
 			cursor->pointer_touch_up = true;
 			dispatch_cursor_button(cursor, &event->touch->base,
-				event->time_msec, BTN_LEFT, WLR_BUTTON_RELEASED);
+				event->time_msec, BTN_LEFT, WL_POINTER_BUTTON_STATE_RELEASED);
 		}
 	} else {
 		seatop_touch_up(seat, event);
@@ -521,7 +521,7 @@ static void handle_touch_cancel(struct wl_listener *listener, void *data) {
 		if (cursor->pointer_touch_id == cursor->seat->touch_id) {
 			cursor->pointer_touch_up = true;
 			dispatch_cursor_button(cursor, &event->touch->base,
-				event->time_msec, BTN_LEFT, WLR_BUTTON_RELEASED);
+				event->time_msec, BTN_LEFT, WL_POINTER_BUTTON_STATE_RELEASED);
 		}
 	} else {
 		seatop_touch_cancel(seat, event);
@@ -738,7 +738,7 @@ static void handle_tool_tip(struct wl_listener *listener, void *data) {
 			event->state == WLR_TABLET_TOOL_TIP_UP) {
 		cursor->simulating_pointer_from_tool_tip = false;
 		dispatch_cursor_button(cursor, &event->tablet->base, event->time_msec,
-			BTN_LEFT, WLR_BUTTON_RELEASED);
+			BTN_LEFT, WL_POINTER_BUTTON_STATE_RELEASED);
 		wlr_seat_pointer_notify_frame(cursor->seat->wlr_seat);
 	} else if (!surface || !wlr_surface_accepts_tablet_v2(tablet_v2, surface)) {
 		// If we started holding the tool tip down on a surface that accepts
@@ -750,7 +750,7 @@ static void handle_tool_tip(struct wl_listener *listener, void *data) {
 		} else {
 			cursor->simulating_pointer_from_tool_tip = true;
 			dispatch_cursor_button(cursor, &event->tablet->base,
-				event->time_msec, BTN_LEFT, WLR_BUTTON_PRESSED);
+				event->time_msec, BTN_LEFT, WL_POINTER_BUTTON_STATE_PRESSED);
 			wlr_seat_pointer_notify_frame(cursor->seat->wlr_seat);
 		}
 	} else {
@@ -853,13 +853,13 @@ static void handle_tool_button(struct wl_listener *listener, void *data) {
 		case WLR_BUTTON_PRESSED:
 			if (cursor->tool_buttons == 0) {
 				dispatch_cursor_button(cursor, &event->tablet->base,
-						event->time_msec, BTN_RIGHT, event->state);
+					event->time_msec, BTN_RIGHT, WL_POINTER_BUTTON_STATE_PRESSED);
 			}
 			break;
 		case WLR_BUTTON_RELEASED:
 			if (cursor->tool_buttons <= 1) {
 				dispatch_cursor_button(cursor, &event->tablet->base,
-						event->time_msec, BTN_RIGHT, event->state);
+					event->time_msec, BTN_RIGHT, WL_POINTER_BUTTON_STATE_RELEASED);
 			}
 			break;
 		}
diff --git a/sway/input/seat.c b/sway/input/seat.c
index 0fd0e8e65fc0..1b29e1a6c0c3 100644
--- a/sway/input/seat.c
+++ b/sway/input/seat.c
@@ -1575,7 +1575,7 @@ struct seat_config *seat_get_config_by_name(const char *name) {
 }
 
 void seat_pointer_notify_button(struct sway_seat *seat, uint32_t time_msec,
-		uint32_t button, enum wlr_button_state state) {
+		uint32_t button, enum wl_pointer_button_state state) {
 	seat->last_button_serial = wlr_seat_pointer_notify_button(seat->wlr_seat,
 			time_msec, button, state);
 }
@@ -1612,7 +1612,7 @@ void seatop_unref(struct sway_seat *seat, struct sway_container *con) {
 
 void seatop_button(struct sway_seat *seat, uint32_t time_msec,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state) {
+		enum wl_pointer_button_state state) {
 	if (seat->seatop_impl->button) {
 		seat->seatop_impl->button(seat, time_msec, device, button, state);
 	}
diff --git a/sway/input/seatop_default.c b/sway/input/seatop_default.c
index 54dac8dab5e7..af22b9cf34f4 100644
--- a/sway/input/seatop_default.c
+++ b/sway/input/seatop_default.c
@@ -287,7 +287,7 @@ static void handle_tablet_tool_tip(struct sway_seat *seat,
 
 static bool trigger_pointer_button_binding(struct sway_seat *seat,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state, uint32_t modifiers,
+		enum wl_pointer_button_state state, uint32_t modifiers,
 		bool on_titlebar, bool on_border, bool on_contents, bool on_workspace) {
 	// We can reach this for non-pointer devices if we're currently emulating
 	// pointer input for one. Emulated input should not trigger bindings. The
@@ -301,7 +301,7 @@ static bool trigger_pointer_button_binding(struct sway_seat *seat,
 	char *device_identifier = device ? input_device_get_identifier(device)
 		: strdup("*");
 	struct sway_binding *binding = NULL;
-	if (state == WLR_BUTTON_PRESSED) {
+	if (state == WL_POINTER_BUTTON_STATE_PRESSED) {
 		state_add_button(e, button);
 		binding = get_active_mouse_binding(e,
 			config->current_mode->mouse_bindings, modifiers, false,
@@ -326,7 +326,7 @@ static bool trigger_pointer_button_binding(struct sway_seat *seat,
 
 static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state) {
+		enum wl_pointer_button_state state) {
 	struct sway_cursor *cursor = seat->cursor;
 
 	// Determine what's under the cursor
@@ -359,7 +359,7 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 
 	// Handle clicking an empty workspace
 	if (node && node->type == N_WORKSPACE) {
-		if (state == WLR_BUTTON_PRESSED) {
+		if (state == WL_POINTER_BUTTON_STATE_PRESSED) {
 			seat_set_focus(seat, node);
 			transaction_commit_dirty();
 		}
@@ -374,7 +374,7 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 			seat_set_focus_layer(seat, layer);
 			transaction_commit_dirty();
 		}
-		if (state == WLR_BUTTON_PRESSED) {
+		if (state == WL_POINTER_BUTTON_STATE_PRESSED) {
 			seatop_begin_down_on_surface(seat, surface, sx, sy);
 		}
 		seat_pointer_notify_button(seat, time_msec, button, state);
@@ -383,7 +383,7 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 
 	// Handle tiling resize via border
 	if (cont && resize_edge && button == BTN_LEFT &&
-			state == WLR_BUTTON_PRESSED && !is_floating) {
+			state == WL_POINTER_BUTTON_STATE_PRESSED && !is_floating) {
 		// If a resize is triggered on a tabbed or stacked container, change
 		// focus to the tab which already had inactive focus -- otherwise, we'd
 		// change the active tab when the user probably just wanted to resize.
@@ -401,7 +401,7 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 	// Handle tiling resize via mod
 	bool mod_pressed = modifiers & config->floating_mod;
 	if (cont && !is_floating_or_child && mod_pressed &&
-			state == WLR_BUTTON_PRESSED) {
+			state == WL_POINTER_BUTTON_STATE_PRESSED) {
 		uint32_t btn_resize = config->floating_mod_inverse ?
 			BTN_LEFT : BTN_RIGHT;
 		if (button == btn_resize) {
@@ -429,7 +429,7 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 	}
 
 	// Handle changing focus when clicking on a container
-	if (cont && state == WLR_BUTTON_PRESSED) {
+	if (cont && state == WL_POINTER_BUTTON_STATE_PRESSED) {
 		// Default case: focus the container that was just clicked.
 		node = &cont->node;
 
@@ -450,7 +450,7 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 
 	// Handle beginning floating move
 	if (cont && is_floating_or_child && !is_fullscreen_or_child &&
-			state == WLR_BUTTON_PRESSED) {
+			state == WL_POINTER_BUTTON_STATE_PRESSED) {
 		uint32_t btn_move = config->floating_mod_inverse ? BTN_RIGHT : BTN_LEFT;
 		if (button == btn_move && (mod_pressed || on_titlebar)) {
 			seatop_begin_move_floating(seat, container_toplevel_ancestor(cont));
@@ -460,7 +460,7 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 
 	// Handle beginning floating resize
 	if (cont && is_floating_or_child && !is_fullscreen_or_child &&
-			state == WLR_BUTTON_PRESSED) {
+			state == WL_POINTER_BUTTON_STATE_PRESSED) {
 		// Via border
 		if (button == BTN_LEFT && resize_edge != WLR_EDGE_NONE) {
 			seat_set_focus_container(seat, cont);
@@ -486,7 +486,7 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 
 	// Handle moving a tiling container
 	if (config->tiling_drag && (mod_pressed || on_titlebar) &&
-			state == WLR_BUTTON_PRESSED && !is_floating_or_child &&
+			state == WL_POINTER_BUTTON_STATE_PRESSED && !is_floating_or_child &&
 			cont && cont->pending.fullscreen_mode == FULLSCREEN_NONE) {
 		// If moving a container by its title bar, use a threshold for the drag
 		if (!mod_pressed && config->tiling_drag_threshold > 0) {
@@ -499,14 +499,14 @@ static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 	}
 
 	// Handle mousedown on a container surface
-	if (surface && cont && state == WLR_BUTTON_PRESSED) {
+	if (surface && cont && state == WL_POINTER_BUTTON_STATE_PRESSED) {
 		seatop_begin_down(seat, cont, sx, sy);
-		seat_pointer_notify_button(seat, time_msec, button, WLR_BUTTON_PRESSED);
+		seat_pointer_notify_button(seat, time_msec, button, WL_POINTER_BUTTON_STATE_PRESSED);
 		return;
 	}
 
 	// Handle clicking a container surface or decorations
-	if (cont && state == WLR_BUTTON_PRESSED) {
+	if (cont && state == WL_POINTER_BUTTON_STATE_PRESSED) {
 		seat_pointer_notify_button(seat, time_msec, button, state);
 		return;
 	}
@@ -691,7 +691,7 @@ static void handle_touch_down(struct sway_seat *seat,
 		pointer_motion(cursor, event->time_msec, &event->touch->base, dx, dy,
 				dx, dy);
 		dispatch_cursor_button(cursor, &event->touch->base, event->time_msec,
-				BTN_LEFT, WLR_BUTTON_PRESSED);
+				BTN_LEFT, WL_POINTER_BUTTON_STATE_PRESSED);
 	}
 }
 
@@ -701,9 +701,9 @@ static void handle_touch_down(struct sway_seat *seat,
 
 static uint32_t wl_axis_to_button(struct wlr_pointer_axis_event *event) {
 	switch (event->orientation) {
-	case WLR_AXIS_ORIENTATION_VERTICAL:
+	case WL_POINTER_AXIS_VERTICAL_SCROLL:
 		return event->delta < 0 ? SWAY_SCROLL_UP : SWAY_SCROLL_DOWN;
-	case WLR_AXIS_ORIENTATION_HORIZONTAL:
+	case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
 		return event->delta < 0 ? SWAY_SCROLL_LEFT : SWAY_SCROLL_RIGHT;
 	default:
 		sway_log(SWAY_DEBUG, "Unknown axis orientation");
diff --git a/sway/input/seatop_down.c b/sway/input/seatop_down.c
index b4421fe6ad0a..44b345d12dd4 100644
--- a/sway/input/seatop_down.c
+++ b/sway/input/seatop_down.c
@@ -143,7 +143,7 @@ static void handle_pointer_axis(struct sway_seat *seat,
 
 static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state) {
+		enum wl_pointer_button_state state) {
 	seat_pointer_notify_button(seat, time_msec, button, state);
 
 	if (seat->cursor->pressed_button_count == 0) {
diff --git a/sway/input/seatop_move_floating.c b/sway/input/seatop_move_floating.c
index ddcd4c53e4ec..0efedecc39df 100644
--- a/sway/input/seatop_move_floating.c
+++ b/sway/input/seatop_move_floating.c
@@ -23,7 +23,7 @@ static void finalize_move(struct sway_seat *seat) {
 
 static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state) {
+		enum wl_pointer_button_state state) {
 	if (seat->cursor->pressed_button_count == 0) {
 		finalize_move(seat);
 	}
diff --git a/sway/input/seatop_move_tiling.c b/sway/input/seatop_move_tiling.c
index 26704d0d91a8..a1e455a97b97 100644
--- a/sway/input/seatop_move_tiling.c
+++ b/sway/input/seatop_move_tiling.c
@@ -409,7 +409,7 @@ static void finalize_move(struct sway_seat *seat) {
 
 static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state) {
+		enum wl_pointer_button_state state) {
 	if (seat->cursor->pressed_button_count == 0) {
 		finalize_move(seat);
 	}
diff --git a/sway/input/seatop_resize_floating.c b/sway/input/seatop_resize_floating.c
index df6830266448..1fe13104b616 100644
--- a/sway/input/seatop_resize_floating.c
+++ b/sway/input/seatop_resize_floating.c
@@ -21,7 +21,7 @@ struct seatop_resize_floating_event {
 
 static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state) {
+		enum wl_pointer_button_state state) {
 	struct seatop_resize_floating_event *e = seat->seatop_data;
 	struct sway_container *con = e->con;
 
diff --git a/sway/input/seatop_resize_tiling.c b/sway/input/seatop_resize_tiling.c
index 869d11b50004..8ab2bcf37fbe 100644
--- a/sway/input/seatop_resize_tiling.c
+++ b/sway/input/seatop_resize_tiling.c
@@ -46,7 +46,7 @@ static struct sway_container *container_get_resize_sibling(
 
 static void handle_button(struct sway_seat *seat, uint32_t time_msec,
 		struct wlr_input_device *device, uint32_t button,
-		enum wlr_button_state state) {
+		enum wl_pointer_button_state state) {
 	struct seatop_resize_tiling_event *e = seat->seatop_data;
 
 	if (seat->cursor->pressed_button_count == 0) {
-- 
2.46.0

