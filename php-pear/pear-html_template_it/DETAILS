         VERSION=1.1.3
     SOURCE_HASH='sha512:bcf9148706cb46281ef83ee39f8a37ccff13708d1ecc1a1f0104b9e8ab70c6eb4bedeed8ea2b0d3403c094777e44a6d57aa4d72c41bc583422364424482ff5ab'
         UPDATED=20051108
           SPELL=pear-html_template_it
    PEAR_PACKAGE=HTML_Template_IT
        WEB_SITE=http://pear.php.net/package/HTML_Template_IT/
      LICENSE[0]=Modified
        KEYWORDS="php"
           SHORT='PEAR: Integrated Templates'
cat << EOF
HTML_Template_IT:
Simple template API.
The Isotemplate API is somewhat tricky for a
beginner although it is the best
one you can build. template::parse() [phplib
template = Isotemplate] requests
you to name a source and a target where the
current block gets parsed into.
Source and target can be block names or even
handler names. This API gives you
a maximum of fexibility but you always have to
know what you do which is
quite unusual for php skripter like me.
I noticed that I do not any control on which
block gets parsed into which one.
If all blocks are within one file, the script
knows how they are nested and in
which way you have to parse them. IT knows that
inner1 is a child of block2, there's
no need to tell him about this.
Features :
* Nested blocks
* Include external file
* Custom tags format (default {mytag})
HTML_Template_ITX :
With this class you get the full power of the
phplib template class.
You may have one file with blocks in it but you
have as well one main file
and multiple files one for each block. This is
quite usefull when you have
user configurable websites. Using blocks not in
the main template allows
you to modify some parts of your layout easily.
EOF

source  $SECTION_DIRECTORY/PEAR_DETAILS
