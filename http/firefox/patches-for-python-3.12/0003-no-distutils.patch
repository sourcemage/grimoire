
# HG changeset patch
# User serge-sans-paille <sguelton@mozilla.com>
# Date 1697615883 0
# Node ID ee3b3779af7fc81a53859fa92856ef9deae17a75
# Parent  9e4f4dfc09522e65b6dfe0113cac8c8fba516089
Bug 1858065 - Replace distutils' StrictVersion r=saschanaz,perftest-reviewers,sparky

distutils have been removed from Python 3.12, so replace it:

Sometimes using packaging's Version, sometimes providing our own in the
case of mozrelease/versions.py. Add more tests for the latter.

Differential Revision: https://phabricator.services.mozilla.com/D190540

diff --git a/python/mozbuild/mozbuild/nodeutil.py b/python/mozbuild/mozbuild/nodeutil.py
--- a/python/mozbuild/mozbuild/nodeutil.py
+++ b/python/mozbuild/mozbuild/nodeutil.py
@@ -1,23 +1,23 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 import os
 import platform
 import subprocess
-from distutils.version import StrictVersion
 
 from mozboot.util import get_tools_dir
 from mozfile import which
+from packaging.version import Version
 from six import PY3
 
-NODE_MIN_VERSION = StrictVersion("12.22.12")
-NPM_MIN_VERSION = StrictVersion("6.14.16")
+NODE_MIN_VERSION = Version("12.22.12")
+NPM_MIN_VERSION = Version("6.14.16")
 
 
 def find_node_paths():
     """Determines the possible paths for node executables.
 
     Returns a list of paths, which includes the build state directory.
     """
     mozbuild_tools_dir = get_tools_dir()
@@ -63,17 +63,17 @@ def check_executable_version(exe, wrap_c
     # If we can't find node, or we don't need to wrap it, fallback to calling
     # direct.
     if not out:
         out = (
             subprocess.check_output([exe, "--version"], universal_newlines=PY3)
             .lstrip("v")
             .rstrip()
         )
-    return StrictVersion(out)
+    return Version(out)
 
 
 def find_node_executable(
     nodejs_exe=os.environ.get("NODEJS"), min_version=NODE_MIN_VERSION
 ):
     """Find a Node executable from the mozbuild directory.
 
     Returns a tuple containing the the path to an executable binary and a
@@ -82,17 +82,17 @@ def find_node_executable(
     """
     if nodejs_exe:
         try:
             version = check_executable_version(nodejs_exe)
         except (subprocess.CalledProcessError, ValueError):
             return None, None
 
         if version >= min_version:
-            return nodejs_exe, version.version
+            return nodejs_exe, version.release
 
         return None, None
 
     # "nodejs" is first in the tuple on the assumption that it's only likely to
     # exist on systems (probably linux distros) where there is a program in the path
     # called "node" that does something else.
     return find_executable("node", min_version)
 
@@ -118,9 +118,9 @@ def find_executable(name, min_version, u
     try:
         version = check_executable_version(exe, use_node_for_version_check)
     except (subprocess.CalledProcessError, ValueError):
         return None, None
 
     if version < min_version:
         return None, None
 
-    return exe, version.version
+    return exe, version.release
diff --git a/python/mozrelease/mozrelease/versions.py b/python/mozrelease/mozrelease/versions.py
--- a/python/mozrelease/mozrelease/versions.py
+++ b/python/mozrelease/mozrelease/versions.py
@@ -1,16 +1,66 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 import re
-from distutils.version import StrictVersion
 
 from looseversion import LooseVersion
+from packaging.version import InvalidVersion
+
+
+class StrictVersion:
+    def __init__(self, vstring):
+        self.parse(vstring)
+
+    def __repr__(self):
+        return "%s ('%s')" % (self.__class__.__name__, str(self))
+
+    def __eq__(self, other):
+        return self._cmp(other) == 0
+
+    def __lt__(self, other):
+        return self._cmp(other) < 0
+
+    def parse(self, vstring):
+        match = self.version_re.match(vstring)
+        if not match:
+            raise InvalidVersion("invalid version number '%s'" % vstring)
+
+        major, minor, patch, pre, pre_num = match.group(1, 2, 4, 5, 6)
+        self.version = int(major), int(minor), int(patch or 0)
+        self.pre = (pre[0], int(pre_num)) if pre else ()
+
+    def __str__(self):
+        return ".".join(map(str, self.version)) + (
+            "".join(map(str, self.pre)) if self.pre else ""
+        )
+
+    def _cmp(self, other):
+        if isinstance(other, str):
+            other = StrictVersion(other)
+        elif not isinstance(other, StrictVersion):
+            raise NotImplementedError
+
+        if self.version < other.version:
+            return -1
+        elif self.version == other.version:
+            if self.pre == other.pre:
+                return 0
+            elif not self.pre:
+                return 1
+            elif not other.pre:
+                return -1
+            elif self.pre < other.pre:
+                return -1
+            else:
+                return 1
+        else:
+            return 1
 
 
 class MozillaVersionCompareMixin:
     def __cmp__(self, other):
         # We expect this function to never be called.
         raise AssertionError()
 
     def _cmp(self, other):
@@ -88,22 +138,22 @@ class LooseModernMozillaVersion(MozillaV
 
     def __repr__(self):
         return "LooseModernMozillaVersion ('%s')" % str(self)
 
 
 def MozillaVersion(version):
     try:
         return ModernMozillaVersion(version)
-    except ValueError:
+    except InvalidVersion:
         pass
     try:
         if version.count(".") == 3:
             return AncientMozillaVersion(version)
-    except ValueError:
+    except InvalidVersion:
         pass
     try:
         return LooseModernMozillaVersion(version)
     except ValueError:
         pass
     raise ValueError("Version number %s is invalid." % version)
 
 
diff --git a/python/mozrelease/test/test_versions.py b/python/mozrelease/test/test_versions.py
--- a/python/mozrelease/test/test_versions.py
+++ b/python/mozrelease/test/test_versions.py
@@ -1,12 +1,16 @@
 import mozunit
 import pytest
 
-from mozrelease.versions import MozillaVersion
+from mozrelease.versions import (
+    AncientMozillaVersion,
+    ModernMozillaVersion,
+    MozillaVersion,
+)
 
 ALL_VERSIONS = [  # Keep this sorted
     "3.0",
     "3.0.1",
     "3.0.2",
     "3.0.3",
     "3.0.4",
     "3.0.5",
@@ -86,16 +90,31 @@ def test_versions_compare_less(comparabl
 
 
 def test_versions_compare_greater(comparable_versions):
     """Test that versions properly compare in order."""
     smaller_version, larger_version = comparable_versions
     assert MozillaVersion(larger_version) > MozillaVersion(smaller_version)
 
 
+def test_ModernMozillaVersion():
+    """Test properties specific to ModernMozillaVersion"""
+    assert isinstance(MozillaVersion("1.2.4"), ModernMozillaVersion)
+    assert isinstance(MozillaVersion("1.2.4rc3"), ModernMozillaVersion)
+    assert MozillaVersion("1.2rc3") == MozillaVersion("1.2.0rc3")
+
+
+def test_AncientMozillaVersion():
+    """Test properties specific to AncientMozillaVersion"""
+    assert isinstance(MozillaVersion("1.2.0.4"), AncientMozillaVersion)
+    assert isinstance(MozillaVersion("1.2.0.4pre1"), AncientMozillaVersion)
+    assert MozillaVersion("1.2pre1") == MozillaVersion("1.2.0pre1")
+    assert MozillaVersion("1.2.0.4pre1") == MozillaVersion("1.2.4pre1")
+
+
 @pytest.mark.parametrize("version", ALL_VERSIONS)
 def test_versions_compare_equal(version):
     """Test that versions properly compare as equal through multiple passes."""
     assert MozillaVersion(version) == MozillaVersion(version)
 
 
 if __name__ == "__main__":
     mozunit.main()
diff --git a/testing/raptor/mach_commands.py b/testing/raptor/mach_commands.py
--- a/testing/raptor/mach_commands.py
+++ b/testing/raptor/mach_commands.py
@@ -258,28 +258,28 @@ class RaptorRunner(MozbuildObject):
             initial_config_file=self.args["initial_config_file"],
         )
         return raptor_mh.run()
 
 
 def setup_node(command_context):
     """Fetch the latest node-16 binary and install it into the .mozbuild directory."""
     import platform
-    from distutils.version import StrictVersion
 
     from mozbuild.artifact_commands import artifact_toolchain
     from mozbuild.nodeutil import find_node_executable
+    from packaging.version import Version
 
     print("Setting up node for browsertime...")
     state_dir = get_state_dir()
     cache_path = os.path.join(state_dir, "browsertime", "node-16")
 
     def __check_for_node():
         # Check standard locations first
-        node_exe = find_node_executable(min_version=StrictVersion("16.0.0"))
+        node_exe = find_node_executable(min_version=Version("16.0.0"))
         if node_exe and (node_exe[0] is not None):
             return node_exe[0]
         if not os.path.exists(cache_path):
             return None
 
         # Check the browsertime-specific node location next
         node_name = "node"
         if platform.system() == "Windows":
diff --git a/tools/browsertime/mach_commands.py b/tools/browsertime/mach_commands.py
--- a/tools/browsertime/mach_commands.py
+++ b/tools/browsertime/mach_commands.py
@@ -76,33 +76,33 @@ def silence():
         sys.stdout, sys.stderr = StringIO(), StringIO()
         yield
     finally:
         sys.stdout, sys.stderr = oldout, olderr
 
 
 def node_path(command_context):
     import platform
-    from distutils.version import StrictVersion
 
     from mozbuild.nodeutil import find_node_executable
+    from packaging.version import Version
 
     state_dir = command_context._mach_context.state_dir
     cache_path = os.path.join(state_dir, "browsertime", "node-16")
 
     NODE_FAILURE_MSG = (
         "Could not locate a node binary that is at least version {}. ".format(
             MIN_NODE_VERSION
         )
         + "Please run `./mach raptor --browsertime -t amazon` to install it "
         + "from the Taskcluster Toolchain artifacts."
     )
 
     # Check standard locations first
-    node_exe = find_node_executable(min_version=StrictVersion(MIN_NODE_VERSION))
+    node_exe = find_node_executable(min_version=Version(MIN_NODE_VERSION))
     if node_exe and (node_exe[0] is not None):
         return os.path.abspath(node_exe[0])
     if not os.path.exists(cache_path):
         raise Exception(NODE_FAILURE_MSG)
 
     # Check the browsertime-specific node location next
     node_name = "node"
     if platform.system() == "Windows":
diff --git a/tools/lint/clippy.yml b/tools/lint/clippy.yml
--- a/tools/lint/clippy.yml
+++ b/tools/lint/clippy.yml
@@ -99,12 +99,12 @@ clippy:
         - security/manager/ssl/osclientcerts/
     extensions:
         - rs
     support-files:
         - 'tools/lint/clippy/**'
     # the version of cargo-clippy is:
     # clippy 0.1.65 (2019147 2022-09-19)
     # we use the date instead to facilitate the check
-    # replacing - by . because Python StrictVersion expects this
+    # replacing - by . because Python packaging.version.Version expects this
     min_clippy_version: 2022.09.19
     type: external
     payload: clippy:lint
diff --git a/tools/power/mach_commands.py b/tools/power/mach_commands.py
--- a/tools/power/mach_commands.py
+++ b/tools/power/mach_commands.py
@@ -1,22 +1,21 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-from distutils.version import StrictVersion
-
 from mach.decorators import Command, CommandArgument
+from packaging.version import Version
 
 
 def is_osx_10_10_or_greater(cls):
     import platform
 
     release = platform.mac_ver()[0]
-    return release and StrictVersion(release) >= StrictVersion("10.10")
+    return release and Version(release) >= Version("10.10")
 
 
 # Get system power consumption and related measurements.
 @Command(
     "power",
     category="misc",
     conditions=[is_osx_10_10_or_greater],
     description="Get system power consumption and related measurements for "

