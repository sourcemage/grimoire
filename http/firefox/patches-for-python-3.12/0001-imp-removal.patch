
# HG changeset patch
# User serge-sans-paille <sguelton@mozilla.com>
# Date 1697534267 0
# Node ID 7f8e4fcfcbfa83ee7504071ce3eb60e0e59319a5
# Parent  6cb5031e76892d4e46a4018c82d59b1a992b596f
Bug 1857516 - Get rid of deprecated imp python module in favor of importlib r=saschanaz

Following the official migration guide from
https://docs.python.org/3/whatsnew/3.12.html#imp

Differential Revision: https://phabricator.services.mozilla.com/D190465

diff --git a/dom/bindings/mozwebidlcodegen/test/test_mozwebidlcodegen.py b/dom/bindings/mozwebidlcodegen/test/test_mozwebidlcodegen.py
--- a/dom/bindings/mozwebidlcodegen/test/test_mozwebidlcodegen.py
+++ b/dom/bindings/mozwebidlcodegen/test/test_mozwebidlcodegen.py
@@ -1,23 +1,22 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-import imp
 import io
 import json
 import os
 import shutil
 import sys
 import tempfile
 import unittest
 
 import mozpack.path as mozpath
-from mozfile import NamedTemporaryFile
+from mozfile import NamedTemporaryFile, load_source
 from mozunit import MockedOpen, main
 from mozwebidlcodegen import WebIDLCodegenManager, WebIDLCodegenManagerState
 
 OUR_DIR = mozpath.abspath(mozpath.dirname(__file__))
 TOPSRCDIR = mozpath.normpath(mozpath.join(OUR_DIR, "..", "..", "..", ".."))
 
 
 class TestWebIDLCodegenManager(unittest.TestCase):
@@ -237,17 +236,17 @@ class TestWebIDLCodegenManager(unittest.
         #
         # Hacking imp to accept a MockedFile doesn't appear possible. So for
         # the first iteration we read from a temp file. The second iteration
         # doesn't need to import, so we are fine with a mocked file.
         fake_path = mozpath.join(OUR_DIR, "fakemodule.py")
         with NamedTemporaryFile("wt") as fh:
             fh.write("# Original content")
             fh.flush()
-            mod = imp.load_source("mozwebidlcodegen.fakemodule", fh.name)
+            mod = load_source("mozwebidlcodegen.fakemodule", fh.name)
             mod.__file__ = fake_path
 
             args = self._get_manager_args()
             m1 = WebIDLCodegenManager(**args)
             with MockedOpen({fake_path: "# Original content"}):
                 try:
                     result = m1.generate_build_files()
                     l = len(result.inputs)
diff --git a/netwerk/dns/prepare_tlds.py b/netwerk/dns/prepare_tlds.py
--- a/netwerk/dns/prepare_tlds.py
+++ b/netwerk/dns/prepare_tlds.py
@@ -1,33 +1,31 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 import codecs
 import encodings.idna
-import imp
-import os
 import re
 import sys
-from make_dafsa import words_to_cxx, words_to_bin
+
+from make_dafsa import words_to_bin, words_to_cxx
 
 """
 Processes a file containing effective TLD data.  See the following URL for a
 description of effective TLDs and of the file format that this script
 processes (although for the latter you're better off just reading this file's
 short source code).
 
 http://wiki.mozilla.org/Gecko:Effective_TLD_Service
 """
 
 
 def getEffectiveTLDs(path):
     file = codecs.open(path, "r", "UTF-8")
-    entries = []
     domains = set()
     for line in file:
         # line always contains a line terminator unless the file is empty
         if len(line) == 0:
             raise StopIteration
         line = line.rstrip()
         # comment, empty, or superfluous line for explicitness purposes
         if line.startswith("//") or not line.strip():
diff --git a/python/mach/mach/command_util.py b/python/mach/mach/command_util.py
--- a/python/mach/mach/command_util.py
+++ b/python/mach/mach/command_util.py
@@ -1,22 +1,24 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 import argparse
 import ast
 import errno
-import imp
 import sys
+import types
 import uuid
 from collections.abc import Iterable
 from pathlib import Path
 from typing import Dict, Optional, Union
 
+from mozfile import load_source
+
 from .base import MissingFileError
 
 INVALID_ENTRY_POINT = r"""
 Entry points should return a list of command providers or directories
 containing command providers. The following entry point is invalid:
 
     %s
 
@@ -406,23 +408,23 @@ def load_commands_from_file(path: Union[
     This takes a path to a file and loads it as a Python module under the
     module name specified. If no name is specified, a random one will be
     chosen.
     """
     if module_name is None:
         # Ensure parent module is present otherwise we'll (likely) get
         # an error due to unknown parent.
         if "mach.commands" not in sys.modules:
-            mod = imp.new_module("mach.commands")
+            mod = types.ModuleType("mach.commands")
             sys.modules["mach.commands"] = mod
 
         module_name = f"mach.commands.{uuid.uuid4().hex}"
 
     try:
-        imp.load_source(module_name, str(path))
+        load_source(module_name, str(path))
     except IOError as e:
         if e.errno != errno.ENOENT:
             raise
 
         raise MissingFileError(f"{path} does not exist")
 
 
 def load_commands_from_spec(
diff --git a/python/mach/mach/test/test_entry_point.py b/python/mach/mach/test/test_entry_point.py
--- a/python/mach/mach/test/test_entry_point.py
+++ b/python/mach/mach/test/test_entry_point.py
@@ -1,13 +1,13 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
-import imp
 import sys
+import types
 from pathlib import Path
 from unittest.mock import patch
 
 from mozunit import main
 
 from mach.base import MachError
 from mach.test.conftest import TestBase
 
@@ -33,17 +33,17 @@ class TestEntryPoints(TestBase):
     def _run_help(self):
         return self._run_mach(["help"], entry_point="mach.providers")
 
     @patch("pkg_resources.iter_entry_points")
     def test_load_entry_point_from_directory(self, mock):
         # Ensure parent module is present otherwise we'll (likely) get
         # an error due to unknown parent.
         if "mach.commands" not in sys.modules:
-            mod = imp.new_module("mach.commands")
+            mod = types.ModuleType("mach.commands")
             sys.modules["mach.commands"] = mod
 
         mock.return_value = [Entry([self.provider_dir])]
         # Mach error raised due to conditions_invalid.py
         with self.assertRaises(MachError):
             self._run_help()
 
     @patch("pkg_resources.iter_entry_points")
diff --git a/python/mozbuild/mozbuild/mach_commands.py b/python/mozbuild/mozbuild/mach_commands.py
--- a/python/mozbuild/mozbuild/mach_commands.py
+++ b/python/mozbuild/mozbuild/mach_commands.py
@@ -23,16 +23,17 @@ from pathlib import Path
 import mozpack.path as mozpath
 from mach.decorators import (
     Command,
     CommandArgument,
     CommandArgumentGroup,
     SettingsProvider,
     SubCommand,
 )
+from mozfile import load_source
 
 import mozbuild.settings  # noqa need @SettingsProvider hook to execute
 from mozbuild.base import (
     BinaryNotFoundException,
     BuildEnvironmentNotFoundException,
     MozbuildObject,
 )
 from mozbuild.base import MachCommandConditions as conditions
@@ -1110,21 +1111,20 @@ def android_gtest(
         adb_path = get_adb_path(command_context)
     if not libxul_path:
         libxul_path = os.path.join(
             command_context.topobjdir, "dist", "bin", "gtest", "libxul.so"
         )
 
     # run gtest via remotegtests.py
     exit_code = 0
-    import imp
 
     path = os.path.join("testing", "gtest", "remotegtests.py")
-    with open(path, "r") as fh:
-        imp.load_module("remotegtests", fh, path, (".py", "r", imp.PY_SOURCE))
+    load_source("remotegtests", path)
+
     import remotegtests
 
     tester = remotegtests.RemoteGTests()
     if not tester.run_gtest(
         test_dir,
         shuffle,
         gtest_filter,
         package,
diff --git a/testing/marionette/harness/marionette_harness/marionette_test/testcases.py b/testing/marionette/harness/marionette_harness/marionette_test/testcases.py
--- a/testing/marionette/harness/marionette_harness/marionette_test/testcases.py
+++ b/testing/marionette/harness/marionette_harness/marionette_test/testcases.py
@@ -1,24 +1,25 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-import imp
+
 import os
 import re
 import sys
 import time
 import unittest
 import warnings
 import weakref
 from unittest.case import SkipTest
 
 import six
 from marionette_driver.errors import TimeoutException, UnresponsiveInstanceException
+from mozfile import load_source
 from mozlog import get_default_logger
 
 
 # With Python 3 both expectedFailure and unexpectedSuccess are
 # available in unittest/case.py but won't work here because both
 # do not inherit from BaseException. And that's currently needed
 # in our custom test status handling in `run()`.
 class expectedFailure(Exception):
@@ -358,31 +359,30 @@ class MarionetteTestCase(CommonTestCase)
         filepath,
         suite,
         testloader,
         marionette,
         fixtures,
         testvars,
         **kwargs
     ):
-        # since we use imp.load_source to load test modules, if a module
-        # is loaded with the same name as another one the module would just be
-        # reloaded.
+        # since load_source caches modules, if a module is loaded with the same
+        # name as another one the module would just be reloaded.
         #
-        # We may end up by finding too many test in a module then since
-        # reload() only update the module dict (so old keys are still there!)
-        # see https://docs.python.org/2/library/functions.html#reload
+        # We may end up by finding too many test in a module then since reload()
+        # only update the module dict (so old keys are still there!) see
+        # https://docs.python.org/2/library/functions.html#reload
         #
-        # we get rid of that by removing the module from sys.modules,
-        # so we ensure that it will be fully loaded by the
-        # imp.load_source call.
+        # we get rid of that by removing the module from sys.modules, so we
+        # ensure that it will be fully loaded by the imp.load_source call.
+
         if mod_name in sys.modules:
             del sys.modules[mod_name]
 
-        test_mod = imp.load_source(mod_name, filepath)
+        test_mod = load_source(mod_name, filepath)
 
         for name in dir(test_mod):
             obj = getattr(test_mod, name)
             if isinstance(obj, six.class_types) and issubclass(obj, unittest.TestCase):
                 testnames = testloader.getTestCaseNames(obj)
                 for testname in testnames:
                     suite.addTest(
                         obj(
diff --git a/testing/mochitest/mach_commands.py b/testing/mochitest/mach_commands.py
--- a/testing/mochitest/mach_commands.py
+++ b/testing/mochitest/mach_commands.py
@@ -9,16 +9,17 @@ import sys
 import warnings
 from argparse import Namespace
 from collections import defaultdict
 
 import six
 from mach.decorators import Command, CommandArgument
 from mozbuild.base import MachCommandConditions as conditions
 from mozbuild.base import MozbuildObject
+from mozfile import load_source
 
 here = os.path.abspath(os.path.dirname(__file__))
 
 
 ENG_BUILD_REQUIRED = """
 The mochitest command requires an engineering build. It may be the case that
 VARIANT=user or PRODUCTION=1 were set. Try re-building with VARIANT=eng:
 
@@ -85,21 +86,18 @@ class MochitestRunner(MozbuildObject):
         resolver = self._spawn(TestResolver)
         tests = list(resolver.resolve_tests(paths=test_paths, cwd=cwd))
         return tests
 
     def run_desktop_test(self, command_context, tests=None, **kwargs):
         """Runs a mochitest."""
         # runtests.py is ambiguous, so we load the file/module manually.
         if "mochitest" not in sys.modules:
-            import imp
-
             path = os.path.join(self.mochitest_dir, "runtests.py")
-            with open(path, "r") as fh:
-                imp.load_module("mochitest", fh, path, (".py", "r", imp.PY_SOURCE))
+            load_source("mochitest", path)
 
         import mochitest
 
         # This is required to make other components happy. Sad, isn't it?
         os.chdir(self.topobjdir)
 
         # Automation installs its own stream handler to stdout. Since we want
         # all logging to go through us, we just remove their handler.
@@ -140,21 +138,19 @@ class MochitestRunner(MozbuildObject):
         self.log_manager.disable_unstructured()
         return result
 
     def run_android_test(self, command_context, tests, **kwargs):
         host_ret = verify_host_bin()
         if host_ret != 0:
             return host_ret
 
-        import imp
+        path = os.path.join(self.mochitest_dir, "runtestsremote.py")
+        load_source("runtestsremote", path)
 
-        path = os.path.join(self.mochitest_dir, "runtestsremote.py")
-        with open(path, "r") as fh:
-            imp.load_module("runtestsremote", fh, path, (".py", "r", imp.PY_SOURCE))
         import runtestsremote
 
         options = Namespace(**kwargs)
 
         from manifestparser import TestManifest
 
         if tests and not options.manifestFile:
             manifest = TestManifest()
@@ -185,24 +181,21 @@ def setup_argument_parser():
     if build_path not in sys.path:
         sys.path.append(build_path)
 
     mochitest_dir = os.path.join(build_obj.topobjdir, "_tests", "testing", "mochitest")
 
     with warnings.catch_warnings():
         warnings.simplefilter("ignore")
 
-        import imp
-
         path = os.path.join(build_obj.topobjdir, mochitest_dir, "runtests.py")
         if not os.path.exists(path):
             path = os.path.join(here, "runtests.py")
 
-        with open(path, "r") as fh:
-            imp.load_module("mochitest", fh, path, (".py", "r", imp.PY_SOURCE))
+        load_source("mochitest", path)
 
         from mochitest_options import MochitestArgumentParser
 
     if conditions.is_android(build_obj):
         # On Android, check for a connected device (and offer to start an
         # emulator if appropriate) before running tests. This check must
         # be done in this admittedly awkward place because
         # MochitestArgumentParser initialization fails if no device is found.
@@ -227,24 +220,21 @@ def setup_junit_argument_parser():
         sys.path.append(build_path)
 
     mochitest_dir = os.path.join(build_obj.topobjdir, "_tests", "testing", "mochitest")
 
     with warnings.catch_warnings():
         warnings.simplefilter("ignore")
 
         # runtests.py contains MochitestDesktop, required by runjunit
-        import imp
-
         path = os.path.join(build_obj.topobjdir, mochitest_dir, "runtests.py")
         if not os.path.exists(path):
             path = os.path.join(here, "runtests.py")
 
-        with open(path, "r") as fh:
-            imp.load_module("mochitest", fh, path, (".py", "r", imp.PY_SOURCE))
+        load_source("mochitest", path)
 
         import runjunit
         from mozrunner.devices.android_device import (
             InstallIntent,
             verify_android_device,
         )
 
         verify_android_device(
diff --git a/testing/mozbase/mozfile/mozfile/mozfile.py b/testing/mozbase/mozfile/mozfile/mozfile.py
--- a/testing/mozbase/mozfile/mozfile/mozfile.py
+++ b/testing/mozbase/mozfile/mozfile/mozfile.py
@@ -17,16 +17,17 @@ from textwrap import dedent
 from six.moves import urllib
 
 __all__ = [
     "extract_tarball",
     "extract_zip",
     "extract",
     "is_url",
     "load",
+    "load_source",
     "copy_contents",
     "match",
     "move",
     "remove",
     "rmtree",
     "tree",
     "which",
     "NamedTemporaryFile",
@@ -627,16 +628,29 @@ def load(resource):
 
     if not is_url(resource):
         # if no scheme is given, it is a file path
         return open(resource)
 
     return urllib.request.urlopen(resource)
 
 
+# see https://docs.python.org/3/whatsnew/3.12.html#imp
+def load_source(modname, filename):
+    import importlib.machinery
+    import importlib.util
+
+    loader = importlib.machinery.SourceFileLoader(modname, filename)
+    spec = importlib.util.spec_from_file_location(modname, filename, loader=loader)
+    module = importlib.util.module_from_spec(spec)
+    sys.modules[module.__name__] = module
+    loader.exec_module(module)
+    return module
+
+
 # We can't depend on mozpack.path here, so copy the 'match' function over.
 
 re_cache = {}
 # Python versions < 3.7 return r'\/' for re.escape('/').
 if re.escape("/") == "/":
     MATCH_STAR_STAR_RE = re.compile(r"(^|/)\\\*\\\*/")
     MATCH_STAR_STAR_END_RE = re.compile(r"(^|/)\\\*\\\*$")
 else:
diff --git a/testing/mozharness/scripts/desktop_unittest.py b/testing/mozharness/scripts/desktop_unittest.py
--- a/testing/mozharness/scripts/desktop_unittest.py
+++ b/testing/mozharness/scripts/desktop_unittest.py
@@ -7,29 +7,29 @@
 # ***** END LICENSE BLOCK *****
 """desktop_unittest.py
 
 author: Jordan Lund
 """
 
 import copy
 import glob
-import imp
 import json
 import multiprocessing
 import os
 import re
 import shutil
 import sys
 from datetime import datetime, timedelta
 
 # load modules from parent dir
 here = os.path.abspath(os.path.dirname(__file__))
 sys.path.insert(1, os.path.dirname(here))
 
+from mozfile import load_source
 from mozharness.base.errors import BaseErrorList
 from mozharness.base.log import INFO, WARNING
 from mozharness.base.script import PreScriptAction
 from mozharness.base.vcs.vcsbase import MercurialScript
 from mozharness.mozilla.automation import TBPL_EXCEPTION, TBPL_RETRY
 from mozharness.mozilla.mozbase import MozbaseMixin
 from mozharness.mozilla.structuredlog import StructuredOutputParser
 from mozharness.mozilla.testing.codecoverage import (
@@ -1193,17 +1193,17 @@ class DesktopUnittest(TestingMixin, Merc
                     suite_category,
                     flavor=flavor,
                     config=self.config,
                     error_list=error_list,
                     log_obj=self.log_obj,
                 )
 
                 if suite_category == "reftest":
-                    ref_formatter = imp.load_source(
+                    ref_formatter = load_source(
                         "ReftestFormatter",
                         os.path.abspath(
                             os.path.join(dirs["abs_reftest_dir"], "output.py")
                         ),
                     )
                     parser.formatter = ref_formatter.ReftestFormatter()
 
                 if self.query_minidump_stackwalk():
diff --git a/testing/web-platform/manifestupdate.py b/testing/web-platform/manifestupdate.py
--- a/testing/web-platform/manifestupdate.py
+++ b/testing/web-platform/manifestupdate.py
@@ -1,34 +1,32 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 import argparse
 import errno
 import hashlib
-import imp
 import os
 import sys
 
 import manifestdownload
 import six
 from mach.util import get_state_dir
+from mozfile import load_source
 from mozlog.structured import commandline
 from six.moves import configparser
 from wptrunner import wptcommandline
 
 manifest = None
 
 
 def do_delayed_imports(wpt_dir):
     global manifest
-    imp.load_source(
-        "localpaths", os.path.join(wpt_dir, "tests", "tools", "localpaths.py")
-    )
+    load_source("localpaths", os.path.join(wpt_dir, "tests", "tools", "localpaths.py"))
     sys.path.insert(0, os.path.join(wpt_dir, "tools", "manifest"))
     import manifest
 
 
 def create_parser():
     p = argparse.ArgumentParser()
     p.add_argument(
         "--rebuild", action="store_true", help="Rebuild manifest from scratch"
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/scope1/redirect.py b/testing/web-platform/tests/service-workers/service-worker/resources/scope1/redirect.py
--- a/testing/web-platform/tests/service-workers/service-worker/resources/scope1/redirect.py
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/scope1/redirect.py
@@ -1,6 +1,8 @@
 import os
-import imp
+
+from tools.wpt.utils import load_source
+
 # Use the file from the parent directory.
-mod = imp.load_source("_parent", os.path.join(os.path.dirname(os.path.dirname(__file__)),
+mod = load_source("_parent", os.path.join(os.path.dirname(os.path.dirname(__file__)),
                                               os.path.basename(__file__)))
 main = mod.main
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/scope2/worker_interception_redirect_webworker.py b/testing/web-platform/tests/service-workers/service-worker/resources/scope2/worker_interception_redirect_webworker.py
--- a/testing/web-platform/tests/service-workers/service-worker/resources/scope2/worker_interception_redirect_webworker.py
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/scope2/worker_interception_redirect_webworker.py
@@ -1,6 +1,8 @@
 import os
-import imp
+
+from tools.wpt.utils import load_source
+
 # Use the file from the parent directory.
-mod = imp.load_source("_parent", os.path.join(os.path.dirname(os.path.dirname(__file__)),
+mod = load_source("_parent", os.path.join(os.path.dirname(os.path.dirname(__file__)),
                                               os.path.basename(__file__)))
 main = mod.main
diff --git a/testing/web-platform/tests/service-workers/service-worker/resources/subdir/worker_interception_redirect_webworker.py b/testing/web-platform/tests/service-workers/service-worker/resources/subdir/worker_interception_redirect_webworker.py
--- a/testing/web-platform/tests/service-workers/service-worker/resources/subdir/worker_interception_redirect_webworker.py
+++ b/testing/web-platform/tests/service-workers/service-worker/resources/subdir/worker_interception_redirect_webworker.py
@@ -1,6 +1,8 @@
 import os
-import imp
+
+from tools.wpt.utils import load_source
+
 # Use the file from the parent directory.
-mod = imp.load_source("_parent", os.path.join(os.path.dirname(os.path.dirname(__file__)),
+mod = load_source("_parent", os.path.join(os.path.dirname(os.path.dirname(__file__)),
                                               os.path.basename(__file__)))
 main = mod.main
diff --git a/testing/web-platform/tests/tools/runner/update_manifest.py b/testing/web-platform/tests/tools/runner/update_manifest.py
--- a/testing/web-platform/tests/tools/runner/update_manifest.py
+++ b/testing/web-platform/tests/tools/runner/update_manifest.py
@@ -1,21 +1,23 @@
 # mypy: ignore-errors
 
-import imp
 import json
 import os
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(__file__)
-localpaths = imp.load_source("localpaths", os.path.abspath(os.path.join(here, os.pardir, "localpaths.py")))
+localpaths = load_source("localpaths", os.path.abspath(os.path.join(here, os.pardir, "localpaths.py")))
 
 root = localpaths.repo_root
 
 from manifest import manifest
 
+
 def main(request, response):
     path = os.path.join(root, "MANIFEST.json")
 
     # TODO make this download rather than rebuilding from scratch when possible
     manifest_file = manifest.load_and_update(root, path, "/", parallel=False)
 
     supported_types = ["testharness", "reftest", "manual"]
     data = {"items": {},
diff --git a/testing/web-platform/tests/tools/wpt/utils.py b/testing/web-platform/tests/tools/wpt/utils.py
--- a/testing/web-platform/tests/tools/wpt/utils.py
+++ b/testing/web-platform/tests/tools/wpt/utils.py
@@ -1,17 +1,17 @@
 # mypy: allow-untyped-defs
 
 import errno
 import logging
 import os
-import sys
 import shutil
 import stat
 import subprocess
+import sys
 import tarfile
 import time
 import zipfile
 from io import BytesIO
 from socket import error as SocketError  # NOQA: N812
 from urllib.request import urlopen
 
 logger = logging.getLogger(__name__)
@@ -161,8 +161,21 @@ def rmtree(path):
 def sha256sum(file_path):
     """Computes the SHA256 hash sum of a file"""
     from hashlib import sha256
     hash = sha256()
     with open(file_path, 'rb') as f:
         for chunk in iter(lambda: f.read(4096), b''):
             hash.update(chunk)
     return hash.hexdigest()
+
+
+# see https://docs.python.org/3/whatsnew/3.12.html#imp
+def load_source(modname, filename):
+    import importlib.machinery
+    import importlib.util
+
+    loader = importlib.machinery.SourceFileLoader(modname, filename)
+    spec = importlib.util.spec_from_file_location(modname, filename, loader=loader)
+    module = importlib.util.module_from_spec(spec)
+    sys.modules[module.__name__] = module
+    loader.exec_module(module)
+    return module
diff --git a/testing/web-platform/tests/tools/wptrunner/wptrunner/stability.py b/testing/web-platform/tests/tools/wptrunner/wptrunner/stability.py
--- a/testing/web-platform/tests/tools/wptrunner/wptrunner/stability.py
+++ b/testing/web-platform/tests/tools/wptrunner/wptrunner/stability.py
@@ -1,30 +1,30 @@
 # mypy: allow-untyped-defs
 
 import copy
 import functools
-import imp
 import io
 import os
 from collections import OrderedDict, defaultdict
 from datetime import datetime
 
 from mozlog import reader
 from mozlog.formatters import JSONFormatter
-from mozlog.handlers import BaseHandler, StreamHandler, LogLevelFilter
+from mozlog.handlers import BaseHandler, LogLevelFilter, StreamHandler
+
+from tools.wpt.utils import load_source
 
 from . import wptrunner
 
 here = os.path.dirname(__file__)
-localpaths = imp.load_source("localpaths", os.path.abspath(os.path.join(here, os.pardir, os.pardir, "localpaths.py")))
+localpaths = load_source("localpaths", os.path.abspath(os.path.join(here, os.pardir, os.pardir, "localpaths.py")))
 from ci.tc.github_checks_output import get_gh_checks_outputter  # type: ignore
 from wpt.markdown import markdown_adjust, table  # type: ignore
 
-
 # If a test takes more than (FLAKY_THRESHOLD*timeout) and does not consistently
 # time out, it is considered slow (potentially flaky).
 FLAKY_THRESHOLD = 0.8
 
 
 class LogActionFilter(BaseHandler):  # type: ignore
 
     """Handler that filters out messages not of a given set of actions.
diff --git a/testing/web-platform/tests/xhr/resources/auth1/auth.py b/testing/web-platform/tests/xhr/resources/auth1/auth.py
--- a/testing/web-platform/tests/xhr/resources/auth1/auth.py
+++ b/testing/web-platform/tests/xhr/resources/auth1/auth.py
@@ -1,12 +1,13 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(os.path.abspath(isomorphic_decode(__file__)))
 
 def main(request, response):
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              u"..",
                                              u"authentication.py"))
     return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth10/auth.py b/testing/web-platform/tests/xhr/resources/auth10/auth.py
--- a/testing/web-platform/tests/xhr/resources/auth10/auth.py
+++ b/testing/web-platform/tests/xhr/resources/auth10/auth.py
@@ -1,12 +1,14 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(os.path.abspath(isomorphic_decode(__file__)))
 
+
 def main(request, response):
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              u"..",
                                              u"authentication.py"))
     return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth11/auth.py b/testing/web-platform/tests/xhr/resources/auth11/auth.py
--- a/testing/web-platform/tests/xhr/resources/auth11/auth.py
+++ b/testing/web-platform/tests/xhr/resources/auth11/auth.py
@@ -1,12 +1,13 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(os.path.abspath(isomorphic_decode(__file__)))
 
 def main(request, response):
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              u"..",
                                              u"authentication.py"))
     return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth2/auth.py b/testing/web-platform/tests/xhr/resources/auth2/auth.py
--- a/testing/web-platform/tests/xhr/resources/auth2/auth.py
+++ b/testing/web-platform/tests/xhr/resources/auth2/auth.py
@@ -1,12 +1,14 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(os.path.abspath(isomorphic_decode(__file__)))
 
+
 def main(request, response):
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              u"..",
                                              u"authentication.py"))
     return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth2/corsenabled.py b/testing/web-platform/tests/xhr/resources/auth2/corsenabled.py
--- a/testing/web-platform/tests/xhr/resources/auth2/corsenabled.py
+++ b/testing/web-platform/tests/xhr/resources/auth2/corsenabled.py
@@ -1,18 +1,19 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(isomorphic_decode(__file__))
 
 def main(request, response):
     response.headers.set(b'Access-Control-Allow-Origin', request.headers.get(b"origin"))
     response.headers.set(b'Access-Control-Allow-Credentials', b'true')
     response.headers.set(b'Access-Control-Allow-Methods', b'GET')
     response.headers.set(b'Access-Control-Allow-Headers', b'authorization, x-user, x-pass')
     response.headers.set(b'Access-Control-Expose-Headers', b'x-challenge, xhr-user, ses-user')
-    auth = imp.load_source(u"", os.path.abspath(os.path.join(here, os.pardir, u"authentication.py")))
+    auth = load_source(u"", os.path.abspath(os.path.join(here, os.pardir, u"authentication.py")))
     if request.method == u"OPTIONS":
         return b""
     else:
         return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth3/auth.py b/testing/web-platform/tests/xhr/resources/auth3/auth.py
--- a/testing/web-platform/tests/xhr/resources/auth3/auth.py
+++ b/testing/web-platform/tests/xhr/resources/auth3/auth.py
@@ -1,12 +1,13 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(os.path.abspath(isomorphic_decode(__file__)))
 
 def main(request, response):
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              u"..",
                                              u"authentication.py"))
     return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth4/auth.py b/testing/web-platform/tests/xhr/resources/auth4/auth.py
--- a/testing/web-platform/tests/xhr/resources/auth4/auth.py
+++ b/testing/web-platform/tests/xhr/resources/auth4/auth.py
@@ -1,12 +1,13 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(os.path.abspath(isomorphic_decode(__file__)))
 
 def main(request, response):
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              u"..",
                                              u"authentication.py"))
     return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth7/corsenabled.py b/testing/web-platform/tests/xhr/resources/auth7/corsenabled.py
--- a/testing/web-platform/tests/xhr/resources/auth7/corsenabled.py
+++ b/testing/web-platform/tests/xhr/resources/auth7/corsenabled.py
@@ -1,20 +1,21 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(isomorphic_decode(__file__))
 
 def main(request, response):
     response.headers.set(b'Access-Control-Allow-Origin', request.headers.get(b"origin"))
     response.headers.set(b'Access-Control-Allow-Credentials', b'true')
     response.headers.set(b'Access-Control-Allow-Methods', b'GET')
     response.headers.set(b'Access-Control-Allow-Headers', b'authorization, x-user, x-pass')
     response.headers.set(b'Access-Control-Expose-Headers', b'x-challenge, xhr-user, ses-user')
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              os.pardir,
                                              u"authentication.py"))
     if request.method == u"OPTIONS":
         return b""
     else:
         return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth8/corsenabled-no-authorize.py b/testing/web-platform/tests/xhr/resources/auth8/corsenabled-no-authorize.py
--- a/testing/web-platform/tests/xhr/resources/auth8/corsenabled-no-authorize.py
+++ b/testing/web-platform/tests/xhr/resources/auth8/corsenabled-no-authorize.py
@@ -1,20 +1,21 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(isomorphic_decode(__file__))
 
 def main(request, response):
     response.headers.set(b'Access-Control-Allow-Origin', request.headers.get(b"origin"))
     response.headers.set(b'Access-Control-Allow-Credentials', b'true')
     response.headers.set(b'Access-Control-Allow-Methods', b'GET')
     response.headers.set(b'Access-Control-Allow-Headers', b'x-user, x-pass')
     response.headers.set(b'Access-Control-Expose-Headers', b'x-challenge, xhr-user, ses-user')
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              os.pardir,
                                              u"authentication.py"))
     if request.method == u"OPTIONS":
         return b""
     else:
         return auth.main(request, response)
diff --git a/testing/web-platform/tests/xhr/resources/auth9/auth.py b/testing/web-platform/tests/xhr/resources/auth9/auth.py
--- a/testing/web-platform/tests/xhr/resources/auth9/auth.py
+++ b/testing/web-platform/tests/xhr/resources/auth9/auth.py
@@ -1,12 +1,13 @@
-import imp
 import os
 
 from wptserve.utils import isomorphic_decode
 
+from tools.wpt.utils import load_source
+
 here = os.path.dirname(os.path.abspath(isomorphic_decode(__file__)))
 
 def main(request, response):
-    auth = imp.load_source(u"", os.path.join(here,
+    auth = load_source(u"", os.path.join(here,
                                              u"..",
                                              u"authentication.py"))
     return auth.main(request, response)
diff --git a/testing/web-platform/update/__init__.py b/testing/web-platform/update/__init__.py
--- a/testing/web-platform/update/__init__.py
+++ b/testing/web-platform/update/__init__.py
@@ -1,23 +1,23 @@
 #!/usr/bin/env python
 #
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-import imp
 import os
 import sys
 
+from mozfile import load_source
 from mozlog import structuredlog
 
 here = os.path.split(__file__)[0]
 
-imp.load_source(
+load_source(
     "localpaths", os.path.join(here, os.pardir, "tests", "tools", "localpaths.py")
 )
 
 from wptrunner.update import WPTUpdate, setup_logging
 from wptrunner.update.base import exit_unclean
 
 from . import updatecommandline
 from .update import UpdateRunner
diff --git a/tools/moztreedocs/mach_commands.py b/tools/moztreedocs/mach_commands.py
--- a/tools/moztreedocs/mach_commands.py
+++ b/tools/moztreedocs/mach_commands.py
@@ -16,16 +16,17 @@ from functools import partial
 from pprint import pprint
 
 import mozpack.path as mozpath
 import sentry_sdk
 import yaml
 from mach.decorators import Command, CommandArgument, SubCommand
 from mach.registrar import Registrar
 from mozbuild.util import memoize
+from mozfile import load_source
 
 here = os.path.abspath(os.path.dirname(__file__))
 topsrcdir = os.path.abspath(os.path.dirname(os.path.dirname(here)))
 DOC_ROOT = os.path.join(topsrcdir, "docs")
 BASE_LINK = "http://gecko-docs.mozilla.org-l1.s3-website.us-west-2.amazonaws.com/"
 
 
 # Helps manage in-tree documentation.
@@ -358,21 +359,18 @@ def manager():
 def toggle_no_autodoc():
     import moztreedocs
 
     moztreedocs._SphinxManager.NO_AUTODOC = True
 
 
 @memoize
 def _read_project_properties():
-    import imp
-
     path = os.path.normpath(manager().conf_py_path)
-    with open(path, "r") as fh:
-        conf = imp.load_module("doc_conf", fh, path, (".py", "r", imp.PY_SOURCE))
+    conf = load_source("doc_conf", path)
 
     # Prefer the Mozilla project name, falling back to Sphinx's
     # default variable if it isn't defined.
     project = getattr(conf, "moz_project_name", None)
     if not project:
         project = conf.project.replace(" ", "_")
 
     return {"project": project, "version": getattr(conf, "version", None)}
diff --git a/tools/tryselect/test/test_mozharness_integration.py b/tools/tryselect/test/test_mozharness_integration.py
--- a/tools/tryselect/test/test_mozharness_integration.py
+++ b/tools/tryselect/test/test_mozharness_integration.py
@@ -1,18 +1,18 @@
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-import imp
 import json
 import os
 
 import mozunit
 import pytest
+from mozfile import load_source
 from tryselect.tasks import build, resolve_tests_by_suite
 
 MOZHARNESS_SCRIPTS = {
     "android_emulator_unittest": {
         "class_name": "AndroidEmulatorTest",
         "configs": [
             "android/android_common.py",
         ],
@@ -50,20 +50,20 @@ MOZHARNESS_SCRIPTS = {
 }
 """A suite being listed in a script's `xfail` list  means it won't work
 properly with MOZHARNESS_TEST_PATHS (the mechanism |mach try fuzzy <path>|
 uses).
 """
 
 
 def get_mozharness_test_paths(name):
-    scriptdir = os.path.join(build.topsrcdir, "testing", "mozharness", "scripts")
-
-    files = imp.find_module(name, [scriptdir])
-    mod = imp.load_module("scripts.{}".format(name), *files)
+    scriptdir = os.path.join(build.topsrcdir, "testing", "mozharness")
+    mod = load_source(
+        "scripts." + name, os.path.join(scriptdir, "scripts", name + ".py")
+    )
 
     class_name = MOZHARNESS_SCRIPTS[name]["class_name"]
     cls = getattr(mod, class_name)
     return cls(require_config_file=False)._get_mozharness_test_paths
 
 
 @pytest.fixture(scope="module")
 def all_suites():
@@ -77,23 +77,25 @@ def all_suites():
         all_suites.append(
             {"flavor": flavor, "subsuite": subsuite, "srcdir_relpath": "test"}
         )
 
     return all_suites
 
 
 def generate_suites_from_config(path):
-    configdir = os.path.join(build.topsrcdir, "testing", "mozharness", "configs")
-
     parent, name = os.path.split(path)
     name = os.path.splitext(name)[0]
 
-    files = imp.find_module("{}".format(name), [os.path.join(configdir, parent)])
-    mod = imp.load_module("config.{}".format(name), *files)
+    configdir = os.path.join(
+        build.topsrcdir, "testing", "mozharness", "configs", parent
+    )
+
+    mod = load_source(name, os.path.join(configdir, name + ".py"))
+
     config = mod.config
 
     for category in sorted(config["suite_definitions"]):
         key = "all_{}_suites".format(category)
         if key not in config:
             yield category,
             continue
 

