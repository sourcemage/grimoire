diff --git a/python/mozbuild/mozbuild/frontend/reader.py b/python/mozbuild/mozbuild/frontend/reader.py
--- a/python/mozbuild/mozbuild/frontend/reader.py
+++ b/python/mozbuild/mozbuild/frontend/reader.py
@@ -465,17 +465,17 @@ class TemplateFunction:
                 return node
 
             def c(new_node):
                 return ast.copy_location(new_node, node)
 
             return c(
                 ast.Subscript(
                     value=c(ast.Name(id=self._global_name, ctx=ast.Load())),
-                    slice=c(ast.Index(value=c(ast.Str(s=node.id)))),
+                    slice=c(ast.Index(value=c(ast.Constant(value=node.id)))),
                     ctx=node.ctx,
                 )
             )
 
 
 class SandboxValidationError(Exception):
     """Represents an error encountered when validating sandbox results."""
 
@@ -1034,33 +1034,33 @@ class BuildReader:
                 # We need to branch to deal with python version differences.
                 if isinstance(target.slice, ast.Constant):
                     # Python >= 3.9
                     assert isinstance(target.slice.value, str)
                     key = target.slice.value
                 else:
                     # Others
                     assert isinstance(target.slice, ast.Index)
-                    assert isinstance(target.slice.value, ast.Str)
-                    key = target.slice.value.s
+                    assert isinstance(target.slice.value, ast.Constant)
+                    key = target.slice.value.value
             elif isinstance(target, ast.Attribute):
                 assert isinstance(target.attr, str)
                 key = target.attr
 
             return name, key
 
         def assigned_values(node):
             value = node.value
             if isinstance(value, ast.List):
                 for v in value.elts:
-                    assert isinstance(v, ast.Str)
-                    yield v.s
+                    assert isinstance(v, ast.Constant)
+                    yield v.value
             else:
-                assert isinstance(value, ast.Str)
-                yield value.s
+                assert isinstance(value, ast.Constant)
+                yield value.value
 
         assignments = []
 
         class Visitor(ast.NodeVisitor):
             def helper(self, node):
                 name, key = assigned_variable(node)
                 if not name:
                     return
diff --git a/python/mozbuild/mozbuild/vendor/rewrite_mozbuild.py b/python/mozbuild/mozbuild/vendor/rewrite_mozbuild.py
--- a/python/mozbuild/mozbuild/vendor/rewrite_mozbuild.py
+++ b/python/mozbuild/mozbuild/vendor/rewrite_mozbuild.py
@@ -322,25 +322,23 @@ def assignment_node_to_source_filename_l
     If this happens, we'll return an empty list. The consequence of this is that we
     won't be able to match a file against this list, so we may not be able to add it.
 
     (But if the file matches a generated list, perhaps it will be included in the
     Sources list automatically?)
     """
     if isinstance(node.value, ast.List) and "elts" in node.value._fields:
         for f in node.value.elts:
-            if not isinstance(f, ast.Constant) and not isinstance(f, ast.Str):
+            if not isinstance(f, ast.Constant):
                 log(
                     "Found non-constant source file name in list: ",
                     ast_get_source_segment(code, f),
                 )
                 return []
-        return [
-            f.value if isinstance(f, ast.Constant) else f.s for f in node.value.elts
-        ]
+        return [f.value for f in node.value.elts]
     elif isinstance(node.value, ast.ListComp):
         # SOURCES += [f for f in foo if blah]
         log("Could not find the files for " + ast_get_source_segment(code, node.value))
     elif isinstance(node.value, ast.Name) or isinstance(node.value, ast.Subscript):
         # SOURCES += other_var
         # SOURCES += files['X64_SOURCES']
         log("Could not find the files for " + ast_get_source_segment(code, node))
     elif isinstance(node.value, ast.Call):


diff --git a/python/mach/mach/command_util.py b/python/mach/mach/command_util.py
--- a/python/mach/mach/command_util.py
+++ b/python/mach/mach/command_util.py
@@ -292,17 +292,17 @@ class DecoratorVisitor(ast.NodeVisitor):
         ]
 
         relevant_kwargs = ["command", "subcommand", "virtualenv_name"]
 
         for decorator in decorators:
             kwarg_dict = {}
 
             for name, arg in zip(["command", "subcommand"], decorator.args):
-                kwarg_dict[name] = arg.s
+                kwarg_dict[name] = arg.value
 
             for keyword in decorator.keywords:
                 if keyword.arg not in relevant_kwargs:
                     # We only care about these 3 kwargs, so we can safely skip the rest
                     continue
 
                 kwarg_dict[keyword.arg] = getattr(keyword.value, "s", "")
 

diff --git a/python/mozbuild/mozbuild/vendor/vendor_python.py b/python/mozbuild/mozbuild/vendor/vendor_python.py
--- a/python/mozbuild/mozbuild/vendor/vendor_python.py
+++ b/python/mozbuild/mozbuild/vendor/vendor_python.py
@@ -35,16 +35,20 @@ EXCLUDED_PACKAGES = {
     "pyproject.toml",
     "requirements.txt",
     # The ansicon package contains DLLs and we don't want to arbitrarily vendor
     # them since they could be unsafe. This module should rarely be used in practice
     # (it's a fallback for old versions of windows). We've intentionally vendored a
     # modified 'dummy' version of it so that the dependency checks still succeed, but
     # if it ever is attempted to be used, it will fail gracefully.
     "ansicon",
+    # jsonschema 4.17.3 is incompatible with Python 3.14+,
+    # but later versions use a dependency with Rust components, which we thus can't vendor.
+    # For now we apply the minimal patch to jsonschema to make it work again.
+    "jsonschema",
 }
 
 
 class VendorPython(MozbuildObject):
     def __init__(self, *args, **kwargs):
         super().__init__(*args, virtualenv_name="vendor", **kwargs)
         self.removed = []
         self.added = []
diff --git a/third_party/python/jsonschema/jsonschema/validators.py b/third_party/python/jsonschema/jsonschema/validators.py
--- a/third_party/python/jsonschema/jsonschema/validators.py
+++ b/third_party/python/jsonschema/jsonschema/validators.py
@@ -870,18 +870,21 @@ class RefResolver:
 
     @lru_cache()  # noqa: B019
     def _find_in_subschemas(self, url):
         subschemas = self._get_subschemas_cache()["$id"]
         if not subschemas:
             return None
         uri, fragment = urldefrag(url)
         for subschema in subschemas:
+            id = subschema["$id"]
+            if not isinstance(id, str):
+                continue
             target_uri = self._urljoin_cache(
-                self.resolution_scope, subschema["$id"],
+                self.resolution_scope, id,
             )
             if target_uri.rstrip("/") == uri.rstrip("/"):
                 if fragment:
                     subschema = self.resolve_fragment(subschema, fragment)
                 self.store[url] = subschema
                 return url, subschema
         return None
 

