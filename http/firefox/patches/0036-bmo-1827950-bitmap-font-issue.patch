
# HG changeset patch
# User Jonathan Kew <jkew@mozilla.com>
# Date 1681473245 0
# Node ID 80b83057f86ba261009ac5cfcf18d200365b6013
# Parent  c251ad7af1d1de2e7642d09349129e3896db20ed
Bug 1827950 - Don't attempt to use font extents if we didn't get a valid 'head' table, or if it's not an sfnt resource. r=lsalzman, a=dsmith

Differential Revision: https://phabricator.services.mozilla.com/D175391

diff --git a/gfx/thebes/gfxFont.cpp b/gfx/thebes/gfxFont.cpp
--- a/gfx/thebes/gfxFont.cpp
+++ b/gfx/thebes/gfxFont.cpp
@@ -2465,17 +2465,25 @@ void gfxFont::Draw(const gfxTextRun* aTe
     }
   } else {
     fontParams.synBoldOnePixelOffset = 0;
     fontParams.extraStrikes = 0;
   }
 
   // Figure out the maximum extents for the font, accounting for synthetic
   // oblique and bold.
-  fontParams.fontExtents = GetFontEntry()->GetFontExtents(mFUnitsConvFactor);
+  if (mFUnitsConvFactor > 0.0) {
+    fontParams.fontExtents = GetFontEntry()->GetFontExtents(mFUnitsConvFactor);
+  } else {
+    // Was it not an sfnt? Maybe on Linux... use arbitrary huge extents, so we
+    // don't inadvertently clip stuff. A bit less efficient than true extents,
+    // but this should be extremely rare.
+    auto size = GetAdjustedSize();
+    fontParams.fontExtents = Rect(-2 * size, -2 * size, 5 * size, 5 * size);
+  }
   if (fontParams.obliqueSkew != 0.0f) {
     gfx::Point p(fontParams.fontExtents.x, fontParams.fontExtents.y);
     gfx::Matrix skew(1, 0, fontParams.obliqueSkew, 1, 0, 0);
     fontParams.fontExtents = skew.TransformBounds(fontParams.fontExtents);
   }
   if (fontParams.extraStrikes) {
     if (fontParams.isVerticalFont) {
       fontParams.fontExtents.height +=
diff --git a/gfx/thebes/gfxFontEntry.cpp b/gfx/thebes/gfxFontEntry.cpp
--- a/gfx/thebes/gfxFontEntry.cpp
+++ b/gfx/thebes/gfxFontEntry.cpp
@@ -279,21 +279,24 @@ uint16_t gfxFontEntry::UnitsPerEm() {
   if (!mUnitsPerEm) {
     AutoTable headTable(this, TRUETYPE_TAG('h', 'e', 'a', 'd'));
     if (headTable) {
       uint32_t len;
       const HeadTable* head =
           reinterpret_cast<const HeadTable*>(hb_blob_get_data(headTable, &len));
       if (len >= sizeof(HeadTable)) {
         mUnitsPerEm = head->unitsPerEm;
+        if (int16_t(head->xMax) > int16_t(head->xMin) &&
+            int16_t(head->yMax) > int16_t(head->yMin)) {
+          mXMin = head->xMin;
+          mYMin = head->yMin;
+          mXMax = head->xMax;
+          mYMax = head->yMax;
+        }
       }
-      mXMin = head->xMin;
-      mYMin = head->yMin;
-      mXMax = head->xMax;
-      mYMax = head->yMax;
     }
 
     // if we didn't find a usable 'head' table, or if the value was
     // outside the valid range, record it as invalid
     if (mUnitsPerEm < kMinUPEM || mUnitsPerEm > kMaxUPEM) {
       mUnitsPerEm = kInvalidUPEM;
     }
   }

