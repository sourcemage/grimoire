install -d ${INSTALL_ROOT}/sys     &&
UDEV_CFG=${INSTALL_ROOT}/etc/udev  &&
DEV_DDIR=/etc/dev.d                &&
SND_DFILE=${DEV_DDIR}/snd/controlC0/alsa.dev &&
mkdir  -p  ${UDEV_CFG}/rules.d     &&
UDFS=etc/udev/udev-devfs.rules     &&
DFS=etc/udev/udev.rules.devfs      &&
NEW_DFS=etc/udev/rules.d/udev.rules.devfs      &&

# moving the old devfs rules to rules.d or updating the new rules
if [ -f ${INSTALL_ROOT}/$DFS ]; then
	install_config_file ${INSTALL_ROOT}/${DFS} ${INSTALL_ROOT}/${NEW_DFS} &&
	rm -f ${INSTALL_ROOT}/$DFS
else
	install_config_file $UDFS ${INSTALL_ROOT}/$NEW_DFS
fi  &&

# installing a new config or backing up the old one before installing the new
# this should just use install_config_file as well after a while.
# the only reason we don't do that now is to avoid users keeping their old
# udev.conf while udev.rules is being moved
if [ ! -f ${UDEV_CFG}/udev.conf ]; then
	install_config_file "$SCRIPT_DIRECTORY/udev.conf"  ${UDEV_CFG}/udev.conf
else
	if cmp "$SCRIPT_DIRECTORY/udev.conf" "${UDEV_CFG}/udev.conf" &>/dev/null ; then
		#to keep it tracked
		install_config_file "$SCRIPT_DIRECTORY/udev.conf" ${UDEV_CFG}/udev.conf
	else
		mv ${UDEV_CFG}/udev.conf ${UDEV_CFG}/udev.conf.backup &&
		cp $SCRIPT_DIRECTORY/udev.conf ${UDEV_CFG}/udev.conf
	fi ;
fi  &&

for file in $SCRIPT_DIRECTORY/rules/* ; do
	install_config_file $file ${UDEV_CFG}/rules.d/$(basename $file)
done  &&

install_config_file $SCRIPT_DIRECTORY/udev.missing  ${UDEV_CFG}/udev.missing      &&
install_config_file extras/run_directory/dev.d/snd/controlC0/alsa.dev ${SND_DFILE} &&
chmod +x ${SND_DFILE} &&
make prefix=${INSTALL_ROOT}/ exec_prefix=${INSTALL_ROOT}/ V=true ${OPTS} install   &&
make EXTRAS="extras/run_directory" prefix=${INSTALL_ROOT}/ exec_prefix=${INSTALL_ROOT}/ \
  V=true ${OPTS} install &&

if [[ "$UDEV_STATIC" == 'y' ]]; then
  pushd __static__ &&
  # we are not supposed to use `make install'
  for __FILE in $UDEV_STATIC_TARGET; do
    install -D $__FILE $INSTALL_ROOT/usr/sbin/$__FILE.static
  done &&
  popd
fi
